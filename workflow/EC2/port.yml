title: A port is not accessible from the Internet.
description: ''
data:
  instanceId: ''
  securityGroupIds: []
  vpcId: ''
  subnetId: ''
  port: 22
  protocol: tcp
input:
  - label: Instance ID
    placeholder: i-01234567891234567
    store: instanceId
  - label: Protocol
    placeholder: tcp / udp / icmp
    store: protocol
  - label: Port
    placeholder: 0-65535
    store: port
steps:
  - name: Instance status check.
    js: |
      let res = await $.aws.ec2.describeInstanceStatus({
        InstanceIds: [$.data.instanceId],
      });

      let state = res.InstanceStatuses[0].InstanceState.Name;
      if (state != "running") {
        $.panic(`Instance is not running. Instance state: ${state}.`);
      }

      let iStatus = res.InstanceStatuses[0].InstanceStatus.Status;
      if (iStatus != "ok") {
        $.panic(`Instance status check failed. Status: ${iStatus}.`);
      }

      let sStatus = res.InstanceStatuses[0].SystemStatus.Status;
      if (sStatus != "ok") {
        $.panic(`System status check failed. Status: ${sStatus}.`);
      }

      $.done("Instance is running, all status check passed.");
  - name: Retrieve instance info, check public IP.
    js: |
      let res = await $.aws.ec2.describeInstances({
        InstanceIds: [$.data.instanceId],
      });

      let publicIps = $.jp.query(res, "$..PrivateIpAddresses..PublicIp");
      if (publicIps.length === 0) {
        $.panic("No public IP is associated to this instance.");
      }

      $.data.securityGroupIds = $.jp.query(res, "$..SecurityGroups[*].GroupId");
      $.data.vpcId = $.jp.query(res, "$..VpcId")[0];
      $.data.subnetId = $.jp.query(res, "$..SubnetId")[0];

      $.done(`/md
      - Public IP: ${publicIps.join(", ")}
      - Security groups: ${$.data.securityGroupIds.join(", ")}
      - VPC ID: ${$.data.vpcId}
      - Subnet ID: ${$.data.subnetId}
      `);
  - name: Check security group inbound rules.
    js: |
      let result = await $.utils.sg.checkPort({
        $,
        direction: "in",
        securityGroupIds: $.data.securityGroupIds,
        protocol: $.data.protocol,
        port: $.data.port,
      });

      if (result.anyTrafficPeer.no && result.peer.no) {
        $.err += `No IP is allowed to access this instance using protocol ${$.data.protocol} at port ${$.data.port}, please fix your security group inbound rules. `;
        $.err += `Security group ids: ${$.data.securityGroupIds.join(", ")}`;
        return;
      }

      if (result.anyTrafficPeer.any) {
        $.done("All traffic allowed from 0.0.0.0/0.");
      } else if (result.anyTrafficPeer.cidr.length !== 0) {
        $.info += `All traffic from those CIDRs are allowed: ${result.anyTrafficPeer.cidr.join(
          ", "
        )}. `;
      }

      if (result.peer.any) {
        $.done(
          `Traffic is allowed from 0.0.0.0/0 using protocol ${$.data.protocol} at port ${$.data.port}.`
        );
      } else if (result.peer.cidr.length !== 0) {
        $.info += `Traffic is allowed from those CIDRs: ${result.peer.cidr.join(
          ", "
        )}. `;
      }

      if ($.info === "") {
        $.err += `No IP is allowed to access this instance using protocol ${$.data.protocol} at port ${$.data.port}, please fix your security group inbound rules. `;
        $.err += `Security group ids: ${$.data.securityGroupIds.join(", ")}`;
        return;
      }
  - name: Check route table Internet Gateway.
    js: |
      let res = await $.utils.vpc.checkSubnetIgw({
        $,
        subnetId: $.data.subnetId,
        vpcId: $.data.vpcId,
      });

      if (res.type == "no") {
        $.panic(`Subnet ${$.data.subnetId} has no route to an Internet Gateway.`);
      }

      if (res.type == "any") {
        $.done(`0.0.0.0/0 will be route to an Internet Gateway`);
      } else if (res.type == "cidr") {
        $.info += `Those CIDR blocks will be route to an Internet Gateway: ${res.cidr.join(
          ", "
        )}. `;
      }
  - name: Check network ACL.
    js: |
      let res = await $.aws.ec2.describeNetworkAcls({
        Filters: [{ Name: "association.subnet-id", Values: [$.data.subnetId] }],
      });
      let inboundRules = $.jp.query(res, "$..Entries[?(!@.Egress)]");
      let outboundRules = $.jp.query(res, "$..Entries[?(@.Egress)]");

      // sort rules by rule number ascent
      inboundRules.sort((a, b) => a.RuleNumber - b.RuleNumber);
      outboundRules.sort((a, b) => a.RuleNumber - b.RuleNumber);

      if (inboundRules.length === 0) {
        $.err = "No inbound rules found.";
        return;
      }
      if (outboundRules.length === 0) {
        $.err = "No outbound rules found.";
        return;
      }

      // use the first rule
      let rIn = inboundRules[0];
      let rOut = outboundRules[0];
      let inNotModified = false;
      let outNotModified = false;

      if (
        rIn.Protocol == "-1" &&
        rIn.RuleAction == "allow" &&
        rIn.CidrBlock == "0.0.0.0/0"
      ) {
        inNotModified = true;
      }
      if (
        rOut.Protocol == "-1" &&
        rOut.RuleAction == "allow" &&
        rOut.CidrBlock == "0.0.0.0/0"
      ) {
        outNotModified = true;
      }

      if (inNotModified) {
        if (outNotModified) {
          $.ok += "All traffics are allowed. ";
          return;
        } else {
          $.info += `Outbound ACLs are modified. Rules: ${outboundRules}. `;
        }
      } else {
        if (outNotModified) {
          $.info += `Inbound ACLs are modified. Rules: ${inboundRules}. `;
        } else {
          $.info += `Inbound & Outbound ACLs are modified. Inbound rules: ${inboundRules}. Outbound rules: ${outboundRules}. `;
        }
      }
